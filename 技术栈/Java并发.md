# Java并发

## 进程与线程

进程是程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建运行到消亡的过程。

在Java中，当我们启动main函数时其实就是启动了一个JVM的进程。

线程是一个比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程，多个线程之间有共享的堆和方法区资源，也有自己的程序计数器、虚拟机栈和本地方法栈。

![image-20220822205352770](/Users/jeremyhuang/Library/Application Support/typora-user-images/image-20220822205352770.png)

## 并发与并行

* 并发：两个及两个以上的作业在同一时间段内执行
* 并行：两个及两个以上的作业在同一时刻执行

## 同步与异步

* 同步：发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待
* 异步：调用在发出之后，不用等待返回结果，该调用直接返回



## 线程的生命周期和状态

Java线程的生命周期：

* NEW：初始状态，被创建单没有调用`start()`
* RUNNABLE:运行状态，线程被调用
* BLOCKED：阻塞状态，需要等待锁释放
* WAITING：等待状态
* TIME_WAITING:超时等待状态，可以在指定的时间后自行返回
* TERMINATED：终止状态

![image-20220822210112720](/Users/jeremyhuang/Library/Application Support/typora-user-images/image-20220822210112720.png)

## 线程死锁

多个线程同时被阻塞，他们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。

## sleep()与wait()

共同点：两者都可以暂停线程的执行

区别：

* sleep()方法没有释放锁，而wait()方法释放了锁
* `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
* `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
* `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。为什么这样设计呢？

## JMM

java memory model内存模型

## volatile关键字

如何保证变量的可见性

在 Java 中，`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

