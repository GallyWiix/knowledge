# 类加载器

- BootstrapClassLoader：最顶层的加载类，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
- ExtensionClassLoader：主要负责加载`%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
- AppClassLoader：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类

## 双亲委派模型

![ClassLoader](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png)

# Java内存区域

![image-20220829124056624](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220829124056624.png)

## 运行时数据区域

1. 程序计数器。是当前线程所执行的字节码的行号指示器
2. Java虚拟机栈。随线程的创建而创建，随线程的死亡而死亡，为虚拟机执行Java方法服务
3. 本地方法栈。为使用到Native方法服务
4. Java堆。所有线程共享的一块内存区域，用于存放对象实例，所有的对象实例以及数组都在这里分配内存
5. 方法区
6. 运行时常量池
7. 直接内存
## 对象的创建
1. 类加载检查
虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，如果这个符号引用的类没有被加载过、解析过，就先执行相应的类加载过程。
2. 分配内存
在类加载检查通过后，接下来虚拟机为新生对象分配内存，这个阶段相当于把一块内存从Java堆中划分出来，分配方式有两种：
- 指针碰撞：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
- 空闲列表：拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
3. 初始化零值
将分配到的内存空间都初始化为零值，保证了对象的实例字段在Java代码中可以不赋初始值就直接使用
4. 设置对象头
虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
5. 执行init方法
从Java程序的角度来看，对象创建才刚开始，`<init>`方法还没有执行，只有进行了初始化，一个真正可用的对象才算完全产生出来

# 垃圾回收

## 如何判断对象可以被回收

- 引用计数法：每个对象都有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，当计数为0时可以被回收。（Java中不采用这个方法）
- 可达性分析法：从GC Roots开始向下搜索，所走过的路径被称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么就可以进行GC（Java中采用这个方法）

## 最终的死亡

在可达性分析中被判定为不可达，还不是最终的死亡，不可达对象被第一次标记并进行一次筛选，判断此对象是否要执行`finalize`方法，被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

此方法已被逐渐弃用
## 废弃常量和不再使用的类
假如字符串常量池中存在字符串”abc“,同时并没有任何String对象引用该字符串的话，就说明常量”abc"是废弃常量，如果发生gc并且被判定是有必要的话，就会被清理
无用的类：

-  该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
-  加载该类的 ClassLoader 已经被回收。
-  该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾回收算法
### 标记-清除算法
首先标记出所有需要回收的对象，在标记完成后统一回收
存在效率问题和空间问题（产生大量不连续的碎片）
### 标记-复制算法
它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。
### 标记-整理算法
根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

## 垃圾收集器
1. Serial收集器
最基本、历史最悠久，简单而高效的单线程垃圾收集器
2. ParNew收集器
是Serial的多线程版本
3. 。。。。

# 虚拟机性能监控、故障处理工具
## jps：查看所有java进程
```powershell
C:\Users\SnailClimb>jps
7360 NettyClient2
17396
7972 Launcher
16504 Jps
17340 NettyServer
```

## jstat:监视虚拟机各种运行情况

```powershell
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
```

## jinfo：实时查看和调正虚拟机各项参数

## jmap：java内存映像工具

## jhat：分析heapdump文件

## jstack：java堆栈跟踪工具

## 可视化故障处理工具：JConsole



# 类文件结构

## Class文件结构

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```

### 魔数

每个Class文件的头4个字节称为魔数，唯一作用是确定这个文件是否能被虚拟机接收

### 版本号

第5和第六是次版本号，第7和第8是主版本号

### 常量池

主次版本号之后的是常量池，常量池的数量是 `constant_pool_count-1`（**常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”**）。

常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

### 访问标志
在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等

### 当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合
类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。

### 字段表集合（Fields)

### 方法表集合（Methods）

### 属性表集合（Attributes）

# 类加载过程

