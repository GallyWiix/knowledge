# Redis基础
redis是一个使用C语言开发的数据库，将数据存储在内存中，所以读写速度非常快，因此redis被广泛运用于缓存方向

## 缓存数据的处理流程
![图片](assets/IMG_7.png)

用户请求的数据如果在缓存中就直接返回，否则才会访问数据库

### 高性能与高并发
![图片](assets/IMG_8.png)

#### 高性能
用户第一次访问数据库中的某些数据，因为是从硬盘中读取，所以过程比较慢。如果用户访问的数据属于高频数据且不会经常改变，则可以将其存放在缓存中，下次访问就直接可以从缓存中获取，直接操作内存当然更快
#### 高并发
一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）

## Redis 的其他用法
- 分布式锁
- 限流
- 消息队列
- 复杂业务场景
- 。。。。

# Redis数据结构
## 常见数据结构
- 基础：String、List、Set、Hash、Zset（有序集合）
- 特殊：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)


# Redis线程模型
## 单线程模型
Redis基于Reactor模式来设计开发增加的一套高效的事件处理模型，就是Redis中的文件时间处理器（file event handler）。由于此处理器是单线程方式运行的，所以我们一般说redis是单线程模型。但redis通过IO多路复用程序来监听来自客户端的大量链接，会将感兴趣的事件及类型注册到内核中，使得redis不再需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。
## 多线程
Redis4.0之后的版本引入了对多线程的支持**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 `redis.conf` ：

```
io-threads-do-reads yes
```

开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 `redis.conf` :

```
io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程
```

# Redis内存管理
一般情况下，我们设置保存的缓存数据都会设置一个过期时间，除了有助于缓解内存的消耗，还可以用于特殊业务场景如短信验证码和用户登录的token等
## Redis如何判断数据是否过期
redis通过过期字典（可以看作是hash表）来保存数据过期的事件。过期字典的键指向redis数据库中的某个key，而值是一个long类型的整数，保存了key所指向的数据库键的过期时间。
## 过期数据删除策略
1. 惰性删除： 只会在取出key的时候才对数据进行过期检查，这样对CPU最友好，但可能会造成太多过期key没有被删除。
2. 定期删除：每隔一段时间抽取一批key执行删除过期key操作。redis通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响
## 内存淘汰机制
1.  **volatile-lru（least recently used）**：从已设置过期时间的数据集（server.db\[i\].expires）中挑选最近最少使用的数据淘汰
2.  **volatile-ttl**：从已设置过期时间的数据集（server.db\[i\].expires）中挑选将要过期的数据淘汰
3.  **volatile-random**：从已设置过期时间的数据集（server.db\[i\].expires）中任意选择数据淘汰
4.  **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5.  **allkeys-random**：从数据集（server.db\[i\].dict）中任意选择数据淘汰
6.  **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

7.  **volatile-lfu（least frequently used）**：从已设置过期时间的数据集（server.db\[i\].expires）中挑选最不经常使用的数据淘汰
8.  **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

# Redis持久化机制
1. **快照 RDB** ： 
通过创建快照来获得存储在内存里面的数据在某个时间点上的副本，可以对快照进行备份或将快照复制到其他服务器
快照持久化是 Redis 默认采用的持久化方式，在 `redis.conf` 配置文件中默认有此下配置：

```
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
```
2. **只追加文件 AOF**
AOF持久化的实时性更好，是主流的持久化方案。可以用过appendonly参数开启
```
appendonly yes
```
在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```
为了兼顾数据和写入性能，用户可以考虑 `appendfsync everysec` 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度

# Redis支持原子性吗
redis不支持回滚的操作，因此redis事务不满足原子性。
redis事务可以理解为：redis事务提供了一种将多个命令请求打包的功能。然后再按顺序执行打包的所有命令，且不会被中途打断。Redis事务不建议在日常开发中使用。

## 如何解决Redis事务的缺陷
Lua脚本

# Redis生产问题
## 缓存穿透
大量请求的key不在缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
### 解决方案
1. 缓存无效key

如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： `SET key value EX 10086` 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。
java代码如下：
```
public Object getObjectInclNullById(Integer id) {
    // 从缓存中获取数据
    Object cacheValue = cache.get(id);
    // 缓存为空
    if (cacheValue == null) {
        // 从数据库中获取
        Object storageValue = storage.get(key);
        // 缓存空对象
        cache.set(key, storageValue);
        // 如果存储数据为空，需要设置一个过期时间(300秒)
        if (storageValue == null) {
            // 必须设置过期时间，否则有被攻击的风险
            cache.expire(key, 60 * 5);
        }
        return storageValue;
    }
    return cacheValue;
}
```
2. 布隆过滤器
将所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中，不存在就将请求参数错误信息发给客户端
![图片](assets/IMG_9.png)

但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： **布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**


## 缓存雪崩
缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受了大量的请求，导致宕机。
### 解决方法
1. 采用redis集群，避免单机出现问题
2. 限流，避免同时处理大量请求
3. 设置不同的失效时间
4. 缓存永不失效

# 缓存与数据库数据的一致性
## 旁路缓存模式
更新DB，然后直接删除cache

# 缓存读写策略
## Cache Aside Pattern(旁路缓存模式)
适合读请求比较多的场景，需要同时维系DB和cache，并且以DB的结果为准
写：先更新DB，然后直接删除cache
读：从cache中读取数据，如果存在就返回，如果不存在就从DB中取，再把数据放到cache中
## Read/Write Through Pattern(读写穿透)
服务端把cache视为主要数据储存，从中读取数据并将数据写入。cache负责将数据写入DB
## Write Behind Pattern（异步缓存写入）
与读写穿透不同，异步缓存写入只更新缓存，不直接更新DB，改为异步批量的方式来更新DB


